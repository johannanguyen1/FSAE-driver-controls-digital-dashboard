// Dashboard 2025 Code

#include <mcp_can.h>  // necessary for CAN Protocol communication commands
#include <SPI.h>      // necessary for serial communication between the SPI devices and the MicroController

// Define the pins between the MCP2515 Board and the MicroController
#define CS_Pin 10
#define INTRPT_Pin 9  // or 0

// Variables for data metrics
unsigned int coolInTemp;
unsigned int coolOutTemp;
unsigned int engnSpeed;  // RPM will be stored here as an integer
unsigned int gear;
unsigned int wheelSpeed;
bool overheating;
unsigned int batteryVoltage;
unsigned int fuelUsed;
unsigned int frontRightTemp;
unsigned int frontLefttTemp;
unsigned int rearRightTemp;
unsigned int rearLeftTemp;


// Flag to indicate CAN initialization
bool can_initialized = false;

// Create an instance of MCP_CAN with the CS pin
MCP_CAN CAN(CS_Pin);

void setup() {
  // Input and Output pin setups
  pinMode(CS_Pin, OUTPUT);
  pinMode(INTRPT_Pin, INPUT);

  // Initialize Serial for debugging
  Serial1.begin(9600);
  // while (!Serial);
  // Serial.println("CAN Receiver Callback");

  // Start the CAN bus at 250 kbps (using MCP_CAN's specific start command)
  if (CAN.begin(MCP_ANY, CAN_250KBPS, MCP_8MHZ) == CAN_OK) {
    // Serial.println("CAN Started");
    can_initialized = true;
  } else {
    // Serial.println("Starting CAN failed!");
    while (1);  // Stop if CAN initialization fails
  }

  // Set CAN mode to normal operation
  CAN.setMode(MCP_NORMAL);
  delay(1000);

}


void loop() {
  // Check for new CAN messages
  if (CAN.checkReceive() == CAN_MSGAVAIL) {
    receiveCANMessage();
  }

  // CAN re-initialization logic (if needed)
  if (!can_initialized) {
    // Serial.println("Attempting to restart CAN...");
    if (CAN.begin(MCP_ANY, CAN_250KBPS, MCP_8MHZ) == CAN_OK) {
      // Serial.println("CAN Restarted");
      can_initialized = true;
    } else {
      // Serial.println("CAN Restart failed");
      delay(1000);  // Wait before retrying
    }
  }
}

void receiveCANMessage() {
  unsigned long canId;
  unsigned char len = 0;
  unsigned char buf[8];

  CAN.readMsgBuf(&canId, &len, buf);

  if (canId == 0x902) {  // Assuming 0x702 is the CAN ID for RPM data
      engnSpeed = extractFloatFromBuffer(buf);  // Convert to 16-bit integer for RPM
      engnSpeed = engnSpeed / 6;
      engnSpeed = 
      // Serial.print("Engine Speed (RPM): ");
      // Serial.println(engnSpeed);  // Print the RPM value
      // Serial1.print("rpm.val=");  // Command for setting the RPM value in Nextion object
      // Serial1.print(engnSpeed);    // Send the RPM value as a number
      // Serial1.write(0xFF);         // End of command sequence
      // Serial1.write(0xFF);
      // Serial1.write(0xFF);

      // Send text to rpmText (this is assuming 'rpmText' is a text box on Nextion)
      // Serial1.print("rpmText.txt=\"poo\""); // Set the text to "poo"
      // Serial1.write(0xFF);         // End of command sequence
      // Serial1.write(0xFF);
      // Serial1.write(0xFF);

      sendToNextion("rpm", String(engnSpeed), true);  
      String rpmText = "RPM"; 
      sendToNextion("rpmText", rpmText, false);  

      gear = buf[7]; 
      sendToNextion("gear", String(gear), true);  // Update gear.val with the numeric value
      String gearText = "Gear";  // Example text value
      sendToNextion("gearText", gearText, false);  // Update gearText.txt with the text value

      // Serial.print("Gear: ");
      // Serial.print(gear);
  } else if (canId == 0x903) {  // Coolant Temperature CAN ID
    coolInTemp = extractFloatFromBuffer(buf);
    coolOutTemp = extractFloatFromBuffer(buf + 4);
    if (coolInTemp > 102) {  // Check for overheating condition, 102C/200F ASK
      overheating = true;
      // Serial.println("Critical Warning: Coolant Overheating!");
                // ADD TO NEXTION 
      String overheatText = "Critical Warning: Coolant Overheating";  
      sendToNextion("overheatText", overheatText, false);  
    } else {
      overheating = false;
    }
                // ADD TO NEXTION 
    sendToNextion("coolInTemp", String(coolInTemp), true); 
    String coolInText = "Coolant Inlet Temp";  
    sendToNextion("coolInText", coolInText, false);  
                // ADD TO NEXTION 
    sendToNextion("coolOutTemp", String(coolOutTemp), true); 
    String coolOutText = "Coolant Outlet Temp";  
    sendToNextion("coolOutText", coolOutText, false);  

    // Serial.print("Coolant Inlet Temperature: ");
    // Serial.println(coolInTemp);
    // Serial.print("Coolant Outlet Temperature: ");
    // Serial.println(coolOutTemp);
  } else if (canId == 0x904) {  
    batteryVoltage = extractFloatFromBuffer(buf);  // Extract battery voltage
    fuelUsed = extractFloatFromBuffer(buf + 4);  // Extract fuel used
    // Serial.print("Battery Voltage: ");
    // Serial.println(batteryVoltage);
    // Serial.print("Fuel Used: ");
    // Serial.println(fuelUsed);

                    // ADD TO NEXTION 
    sendToNextion("batteryVoltage", String(batteryVoltage), true); 
    String batteryText = "Battery Voltage";  
    sendToNextion("batteryText", batteryText, false);  
                // ADD TO NEXTION 
    sendToNextion("fuelUsed", String(fuelUsed), true); 
    String fuelUsedText = "Fuel Used";  
    sendToNextion("fuelUsedText", fuelUsedText, false);  

  }
  // } else if (canId == 0x905) {  
  //   frontRightTemp = extractFloatFromBuffer(buf);  // Extract front-right tire temp
  //   frontLeftTemp = extractFloatFromBuffer(buf + 4);  // Extract front-left tire temp
  //   Serial.print("Front Right Tire Temp: ");
  //   Serial.println(frontRightTemp);
  //   Serial.print("Front Left Tire Temp: ");
  //   Serial.println(frontLeftTemp);
  // } else if (canId == 0x906) {  
  //   rearRightTemp = extractFloatFromBuffer(buf);  // Extract rear-right tire temp
  //   rearLeftTemp = extractFloatFromBuffer(buf + 4);  // Extract rear-left tire temp
  //   Serial.print("Rear Right Tire Temp: ");
  //   Serial.println(rearRightTemp);
  //   Serial.print("Rear Left Tire Temp: ");
  //   Serial.println(rearLeftTemp);
  // }
  // Serial.println();
}

// Helper function to convert CAN buffer to float
float extractFloatFromBuffer(unsigned char* buf) {
  union {
    uint32_t bits;
    float number;
  } data;

  data.bits = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
  return data.number;
}

void sendToNextion(const String& objectName, const String& value, bool isNumeric) {
    if (isNumeric) {
        Serial1.print(objectName + ".val=");  // Command for setting numeric value
        Serial1.print(value);                // Send the value as a number
    } else {
        Serial1.print(objectName + ".txt=\"");  // Command for setting text value
        Serial1.print(value);                   // Send the value as a string
        Serial1.print("\"");
    }
    // End of command sequence (required by Nextion protocol)
    Serial1.write(0xFF);
    Serial1.write(0xFF);
    Serial1.write(0xFF);
}


  // Serial1.print("gear.val=");  // Command for setting the Gear value in Nextion object
  // Serial1.print(gear);         // Send the Gear value as a number
  // Serial1.write(0xFF);         // End of command sequence
  // Serial1.write(0xFF);
  // Serial1.write(0xFF);

  // // Send text to gearText (this is assuming 'gearText' is a text box on Nextion)
  // Serial1.print("gearText.txt=\"pee\""); // Set the text to "pee"
  // Serial1.write(0xFF);         // End of command sequence
  // Serial1.write(0xFF);
  // Serial1.write(0xFF);
