// Dashboard 2025 Code

#include <mcp_can.h>  // necessary for CAN Protocol communication commands
#include <SPI.h>      // necessary for serial communication between the SPI devices and the MicroController

// Define the pins between the MCP2515 Board and the MicroController
#define CS_Pin 10
#define INTRPT_Pin 9  // or 0

// Variables for data metrics
unsigned int coolInTemp;
unsigned int coolOutTemp;
unsigned int engnSpeed;  // RPM will be stored here as an integer
unsigned int gear;
unsigned int wheelSpeed;
bool overheating;
unsigned int batteryVoltage;
unsigned int fuelUsed;

unsigned int frontRightTemp;
unsigned int frontLeftTemp;
unsigned int rearRightTemp;
unsigned int rearLeftTemp;




// Flag to indicate CAN initialization
bool can_initialized = false;

// Create an instance of MCP_CAN with the CS pin
MCP_CAN CAN(CS_Pin);

void setup() {
  // Input and Output pin setups
  pinMode(CS_Pin, OUTPUT);
  pinMode(INTRPT_Pin, INPUT);

  // Initialize Serial for debugging
  Serial1.begin(9600);
  // while (!Serial);
  // Serial.println("CAN Receiver Callback");

  // Start the CAN bus at 250 kbps (using MCP_CAN's specific start command)
  if (CAN.begin(MCP_ANY, CAN_250KBPS, MCP_8MHZ) == CAN_OK) {
    Serial.println("CAN Started");
    can_initialized = true;
  } else {
    Serial.println("Starting CAN failed!");
    while (1);  // Stop if CAN initialization fails
  }

  // Set CAN mode to normal operation
  CAN.setMode(MCP_NORMAL);
  delay(1000);

}


void loop() {
  // Check for new CAN messages
  if (CAN.checkReceive() == CAN_MSGAVAIL) {
    receiveCANMessage();
  }

  // CAN re-initialization logic (if needed)
  if (!can_initialized) {
    // Serial.println("Attempting to restart CAN...");
    if (CAN.begin(MCP_ANY, CAN_250KBPS, MCP_8MHZ) == CAN_OK) {
      // Serial.println("CAN Restarted");
      can_initialized = true;
    } else {
      // Serial.println("CAN Restart failed");
      delay(1000);  // Wait before retrying
    }
  }
}

void receiveCANMessage() {
  unsigned long canId;
  unsigned char len = 0;
  unsigned char buf[8];

  CAN.readMsgBuf(&canId, &len, buf);

  if (canId == 0x102) {  // Assuming 0x902 is the CAN ID for RPM data
      engnSpeed = extractFloatFromBuffer(buf);  // Convert to 16-bit integer for RPM
      engnSpeed = engnSpeed / 6;
      Serial.print("Engine Speed (RPM): ");
      Serial.println(engnSpeed);  // Print the RPM value
      // Serial1.print("rpm.val=");  // Command for setting the RPM value in Nextion object
      // Serial1.print(engnSpeed);    // Send the RPM value as a number
      // Serial1.write(0xFF);         // End of command sequence
      // Serial1.write(0xFF);
      // Serial1.write(0xFF);

      // Send text to rpmText (this is assuming 'rpmText' is a text box on Nextion)
      // Serial1.print("rpmText.txt=\"poo\""); // Set the text to "poo"
      // Serial1.write(0xFF);         // End of command sequence
      // Serial1.write(0xFF);
      // Serial1.write(0xFF);

      gear = buf[7]; 
      Serial.print("Gear: ");
      Serial.println(gear);
  } else if (canId == 0x103) {  // Coolant Temperature CAN ID
    coolInTemp = extractFloatFromBuffer(buf);
    coolOutTemp = extractFloatFromBuffer(buf + 4);
    if (coolInTemp - coolOutTemp < 5) {  // Check for overheating condition, 5C/9F
      overheating = true;
      Serial.println("Critical Warning: Coolant Overheating!");
    } else {
      overheating = false;
    }
    Serial.print("Coolant Inlet Temperature: ");
    Serial.println(coolInTemp);
    Serial.print("Coolant Outlet Temperature: ");
    Serial.println(coolOutTemp);
  } else if (canId == 0x104) {  
    batteryVoltage = extractFloatFromBuffer(buf);  // Extract battery voltage
    fuelUsed = extractFloatFromBuffer(buf + 4);  // Extract fuel used
    Serial.print("Battery Voltage: ");
    Serial.println(batteryVoltage);
    Serial.print("Fuel Used: ");
    Serial.println(fuelUsed);
  } else if (canId == 0x105) {  
    frontRightTemp = extractFloatFromBuffer(buf);  // Extract front-right tire temp
    frontLeftTemp = extractFloatFromBuffer(buf + 4);  // Extract front-left tire temp
    Serial.print("Front Right Tire Temp: ");
    Serial.println(frontRightTemp);
    Serial.print("Front Left Tire Temp: ");
    Serial.println(frontLeftTemp);
  } else if (canId == 0x106) {  
    rearRightTemp = extractFloatFromBuffer(buf);  // Extract rear-right tire temp
    rearLeftTemp = extractFloatFromBuffer(buf + 4);  // Extract rear-left tire temp
    Serial.print("Rear Right Tire Temp: ");
    Serial.println(rearRightTemp);
    Serial.print("Rear Left Tire Temp: ");
    Serial.println(rearLeftTemp);
  }
}

// Helper function to convert CAN buffer to float
float extractFloatFromBuffer(unsigned char* buf) {
  union {
    uint32_t bits;
    float number;
  } data;

  data.bits = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
  return data.number;
}


// Helper function to convert CAN buffer to unsigned integer
unsigned int extractUnsignedIntFromBuffer(unsigned char* buf) {
    unsigned int value;
    memcpy(&value, buf, sizeof(value));
    return value;
}

// Helper function to convert CAN buffer to signed integer
int extractIntFromBuffer(unsigned char* buf) {
    int value;
    memcpy(&value, buf, sizeof(value));
    return value;
}


  // Serial1.print("gear.val=");  // Command for setting the Gear value in Nextion object
  // Serial1.print(gear);         // Send the Gear value as a number
  // Serial1.write(0xFF);         // End of command sequence
  // Serial1.write(0xFF);
  // Serial1.write(0xFF);

  // // Send text to gearText (this is assuming 'gearText' is a text box on Nextion)
  // Serial1.print("gearText.txt=\"pee\""); // Set the text to "pee"
  // Serial1.write(0xFF);         // End of command sequence
  // Serial1.write(0xFF);
  // Serial1.write(0xFF);
